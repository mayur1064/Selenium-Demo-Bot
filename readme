import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.vault.authentication.ClientCertificateAuthentication;
import org.springframework.vault.client.VaultClients;
import org.springframework.vault.client.VaultEndpoint;
import org.springframework.vault.config.ClientHttpRequestFactoryFactory;
import org.springframework.vault.core.VaultTemplate;
import org.springframework.vault.support.SslConfiguration;
import org.springframework.vault.support.SslConfiguration.KeyStoreConfiguration;

import javax.net.ssl.KeyManagerFactory;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.StringReader;
import java.net.URI;
import java.security.KeyFactory;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Security;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;

@Configuration
public class VaultConfig {

    private static final String VAULT_URI = "https://your-vault-server:8200";
    private static final String CERT_PATH = "/path/to/your/certificate.pem";
    private static final String KEY_PATH = "/path/to/your/private-key.pem";
    private static final String PASSWORD = ""; // Empty or passphrase if any

    static {
        // Add BouncyCastle provider for PEM parsing
        Security.addProvider(new BouncyCastleProvider());
    }

    @Bean
    public VaultTemplate vaultTemplate() throws Exception {
        // 1. Create a KeyStore dynamically in memory
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        keyStore.load(null, null);

        // Load certificate and key
        Certificate certificate = loadCertificate(CERT_PATH);
        PrivateKey privateKey = loadPrivateKey(KEY_PATH);

        // Add the certificate and private key to the KeyStore
        keyStore.setKeyEntry("vault-client", privateKey, PASSWORD.toCharArray(), new Certificate[]{certificate});

        // 2. Configure Vault endpoint
        VaultEndpoint vaultEndpoint = VaultEndpoint.from(URI.create(VAULT_URI));

        // 3. Create SslConfiguration
        KeyStoreConfiguration keyStoreConfig = KeyStoreConfiguration.of(keyStore, PASSWORD.toCharArray());
        SslConfiguration sslConfiguration = SslConfiguration.of(keyStoreConfig);

        // 4. Set up Client Certificate Authentication
        ClientCertificateAuthentication clientCertificateAuthentication = 
                new ClientCertificateAuthentication(sslConfiguration);

        // 5. Return VaultTemplate
        return new VaultTemplate(vaultEndpoint, clientCertificateAuthentication,
                ClientHttpRequestFactoryFactory.create(sslConfiguration));
    }

    private Certificate loadCertificate(String certPath) throws Exception {
        try (InputStream certInputStream = new FileInputStream(certPath)) {
            CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
            return certFactory.generateCertificate(certInputStream);
        }
    }

    private PrivateKey loadPrivateKey(String keyPath) throws Exception {
        String keyContent = new String(java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(keyPath)));
        keyContent = keyContent.replaceAll("-----BEGIN PRIVATE KEY-----", "")
                               .replaceAll("-----END PRIVATE KEY-----", "")
                               .replaceAll("\\s", "");

        byte[] keyBytes = Base64.getDecoder().decode(keyContent);
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        return keyFactory.generatePrivate(keySpec);
    }
}
