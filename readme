<properties>
    <java.version>21</java.version>
    <spring-boot.version>3.2.2</spring-boot.version>
    <cloudevents.version>2.5.0</cloudevents.version>
</properties>

<dependencies>
    <!-- Spring Boot -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>

    <!-- Kafka -->
    <dependency>
        <groupId>org.springframework.kafka</groupId>
        <artifactId>spring-kafka</artifactId>
    </dependency>

    <!-- CloudEvents -->
    <dependency>
        <groupId>io.cloudevents</groupId>
        <artifactId>cloudevents-core</artifactId>
        <version>${cloudevents.version}</version>
    </dependency>
    <dependency>
        <groupId>io.cloudevents</groupId>
        <artifactId>cloudevents-json-jackson</artifactId>
        <version>${cloudevents.version}</version>
    </dependency>

    <!-- Jackson -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
    </dependency>
</dependencies>


public record GenericEvent(
        String entityId,
        Map<String, Object> data
) {}


@Service
public class CloudEventProducer {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final ObjectMapper objectMapper;
    private final String topic;

    public CloudEventProducer(
            KafkaTemplate<String, Object> kafkaTemplate,
            ObjectMapper objectMapper,
            @Value("${app.kafka.topic}") String topic) {
        this.kafkaTemplate = kafkaTemplate;
        this.objectMapper = objectMapper;
        this.topic = topic;
    }

    public void sendEvent(String eventType, GenericEvent payload) {

        CloudEvent cloudEvent = CloudEventBuilder.v1()
                .withId(UUID.randomUUID().toString())
                .withSource(URI.create("springboot://producer"))
                .withType(eventType)
                .withTime(OffsetDateTime.now())
                .withDataContentType("application/json")
                .withData(serialize(payload))
                .build();

        Message<CloudEvent> message = MessageBuilder
                .withPayload(cloudEvent)
                .setHeader(KafkaHeaders.TOPIC, topic)
                .setHeader("ce_type", eventType) // explicit header
                .build();

        kafkaTemplate.send(message);
    }

    private byte[] serialize(Object obj) {
        try {
            return objectMapper.writeValueAsBytes(obj);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}


@Configuration
public class KafkaConsumerConfig {

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, CloudEvent>
    kafkaListenerContainerFactory(
            ConsumerFactory<String, CloudEvent> consumerFactory,
            @Value("${app.kafka.consume-event-type}") String eventType) {

        ConcurrentKafkaListenerContainerFactory<String, CloudEvent> factory =
                new ConcurrentKafkaListenerContainerFactory<>();

        factory.setConsumerFactory(consumerFactory);

        factory.setRecordFilterStrategy(record -> {
            Header header = record.headers().lastHeader("ce_type");
            if (header == null) return true;

            String value = new String(header.value());
            return !eventType.equals(value); // true = filtered out
        });

        return factory;
    }
}


@Component
public class CloudEventConsumer {

    private final ObjectMapper objectMapper;

    public CloudEventConsumer(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @KafkaListener(
            topics = "${app.kafka.topic}",
            containerFactory = "kafkaListenerContainerFactory"
    )
    public void consume(CloudEvent event) {

        GenericEvent payload = deserialize(event.getData().toBytes());
        System.out.println("Processed event: " + payload);
    }

    private GenericEvent deserialize(byte[] data) {
        try {
            return objectMapper.readValue(data, GenericEvent.class);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}


producer.sendEvent("order.created",
        new GenericEvent("ORD-1", Map.of("amount", 100)));

producer.sendEvent("order.cancelled",
        new GenericEvent("ORD-1", Map.of("reason", "USER_REQUEST")));
